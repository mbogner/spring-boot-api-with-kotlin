# Spring Boot API with Kotlin

This demo application shows how to create an HTTP REST API based on Spring Boot 2 and Kotlin.

## Important Notes

### Swagger Codegen

It is using swagger code generation for creating boilerplate code which helps a lot to sync documentation and code
because you have to change the swagger file to have the basic code (re-)generated before you can start or continue
coding. So in this case we chose the specification first approach and generate code from the specs.

### Dozer/MapStruct

The app uses dozer/MapStruct for translating between DTO and Entity layer. Both just for showcasing how to use them.
MapStruct should result in faster runtime because it generates mapping code similar to what one would write manually for
mapping objects. Dozer on the other hand is a framework that is configured through config files in the classpath and
adds extra boot time and calculates mappings on runtime with reflection which is known to be slow.

### Logging

Further the application uses AOP to log and measure HTTP method calls. The implementations in the delegates should all
have @LoggedMethod annotation for using this feature. A method with this annotation will log that it is called incl. all
parameters (if not masked by adding the param name to the mask array). The log also contains how long it took to be
executed and the method also adds a unique correlation id before the call is executed so that the MDC contains a unique
identifier for all subsequent calls of other methods within the same execution.

### Error Handling

Error handling is based on an ErrorCode interface which is implemented by the enum ApiErrorCode. This is a preparation
for being able to have different ErrorCode implementations in different parts of a bigger application. The error handler
itself is implemented in ApiExceptionHandler which is responsible for translating the codes to properly translated error
messages which originate from locale/messages resource bundle.

### Entities

AbstractEntity defines default implementations for toString, equals and hashCode which is very important in JPA
applications that make use of @OneToOne, @ManyToOne, @OneToOne or @ManyToMany relations. The extension of this class
AbstractVersionedMutableEntity adds createdAt and updatedAt fields plus a lockVersion which is important for optimistic
locking. Using data classes for JPA Entities is discouraged.

Entities are using UUID as id. For being able to have autogenerated and custom set values in the id field an extensions
to UUIDGenerator was necessary. See AssignableUUIDGenerator for more details. Without this class you can't assign ids
yourself but can only use generated values.

### Repositories

There is a custom extension for JpaRepository so that you can override existing methods or add global custom methods to
your repository layer. This custom implementation is also extending JpaSpecificationExecutor so that the repos are able
to handle Specification pattern style queries.

### Flyway

The application is relying on flyway to bring the database to the desired state. Usage of ddl-auto in hibernate is
highly discouraged for production systems, and we highly recommend using a migration tool like flyway in every
application instead of relying on hibernate ddl-auto. The only correct setting for this is "validate".

### Extension Functions

StringExtensions.kt contains some easy examples for extensions of Strings in the application. You can do the same with
all other base types as well.

## Infrastructure

### Docker

The application is using PostgreSQL as database which can be started with the added docker-compose.yml file for local
development. WARNING: Stored data in the defined container won't survive recreation of the container because it doesn't
define any data container nor a path to persist data.

### Maven

In this application I used Maven instead of Gradle to see how easy or difficult it would be to recreate our typical
gradle configuration. So there is no special reason why this is Maven instead of Gradle but to be honest Maven was very
easy to understand and much more stable in my IDE (intellij) than Gradle.

## Getting started

We assume you have Java 11, Docker and docker-compose already set up.

```bash
git clone git@github.com:mbogner/spring-boot-api-with-kotlin.git
cd spring-boot-api-with-kotlin
docker-compose up -d
./mvnw clean package
java -jar target/spring-api.jar
```

Database is required for tests.
